---
title: "proyecto regression"
author: "vega carmona"
date: "2025-09-30"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
# Paquetes básicos que usas
library(tidyverse)   # incluye ggplot2 y dplyr (%>%)
library(DataExplorer)
library(inspectdf)
library(skimr)
library(SmartEDA)
library(naniar)
library(forcats)# utilidades para factors
library(readr)

# Evitar el warning de xts vs dplyr::lag (si lo usas)
options(xts.warn_dplyr_breaks_lag = FALSE)
```

```{r}
# setwd("C:/Users/Vega Carmona/OneDrive/ESTADISTICA/QUART/MEMDA/projecte")
# setwd("C:/Users/Usuario/OneDrive/Documentos/ESTADÍSTICA/4-1 ESTADÍSTICA/MEMDA/TRABAJO")
setwd("C:/Users/raque/OneDrive/Documentos/GitHub/Trabajo_MEMDA")
datos <- read_csv("train.csv")
test <- read_csv("test.csv")
```

```{r, warning=FALSE}
str(datos)
```

```{r}
# --- Preliminaries ---------------------------------------------------------
# Conversión a factores
datos$key <- factor(datos$key)
datos$audio_mode <- factor(datos$audio_mode) # 0 = menor, 1 = mayor
datos$time_signature <- factor(datos$time_signature)

clases <- sapply(datos, class)

varNum <- names(clases)[which(clases %in% c("numeric", "integer"))]
varCat <- names(clases)[which(clases %in% c("character", "factor"))]
```

```{r}
# Comprobación
str(datos)
```

```{r}
# --- 2.1.1 Numerical: Description -----------------------------------------
library(psych)
psych::describe(datos[, varNum])
```


En base a este resumen estadístico se puede afirmar que la mayoría de las canciones no son en vivo, dado que el promedio de la variable $liveness$ es bastante bajo. Respecto a el volumen de las canciones, teniendo en cuenta que $loudness$ es una característica que oscila entre -36.73dB	y 1.34dB, su valor medio parece indicar que es relativamente alto. La media de $danceability$ apunta que las canciones son bastante bailables, y el valor esperado de $audio_valence$ muestra que las canciones tienden a tener emociones más alegres y positivas, ya que es ligeramente superior a 0,5. Asimismo, haciendo referencia a cómo de energéticas o animadas son dichas canciones, $energy$ señala que, en promedio, puede decirse que lo son bastante. En cuanto al grado acústico, observando que el valor medio es bajo, se podría deducir que mayoritariamente las canciones son producidas electrónicamente. Por último, se podría añadir que gran parte de las canciones no son habladas, pues la variable $speechiness$ tiene un promedio bajo.
Destaca la variabilidad del nivel de popularidad ($song_popularity$), con canciones desde poco conocidas hasta muy populares.


```{r}
# --- 2.1.1 Numerical: Graphics (base) -------------------------------------
par(mfrow = c(2, 4))
for (var in varNum) {
  hist(datos[, var], main = paste0("Histograma variable ", var))
  boxplot(datos[, var], main = paste0("Boxplot variable ", var))
}
par(mfrow = c(1, 1))
```


# --- 2.1.1 Numerical: Graphics (ggplot2 + patchwork) ----------------------

```{r, eval=FALSE}
library(ggplot2)
library(patchwork)

plots <- list()

for (var in varNum) {
  histo <- ggplot(datos, aes(x = .data[[var]])) +
    geom_histogram(aes(y = ..density..), colour = "black", fill = "white") +
    geom_density(alpha = .2, fill = "#FF6666") +
    geom_vline(aes(xintercept = mean(.data[[var]], na.rm = TRUE)),
               color = "blue", linetype = "dashed", linewidth = 1) +
    ggtitle(paste("Histograma de", var))
  boxp <- ggplot(datos, aes(x = .data[[var]])) +
    geom_boxplot(outlier.colour = "red", outlier.shape = 8, outlier.size = 4) +
    ggtitle(paste("Boxplot de", var))

  plots <- append(plots, list(histo, boxp))
}
```


# Combinar en un grid automático con 2 columnas

```{r, eval=FALSE, include=FALSE}
final_plot <- Reduce(`+`, plots) + plot_layout(ncol = 2)
final_plot
```


```{r}
# --- 2.1.2 Categorical: Description ---------------------------------------
for (var in varCat) {
  tablaAbs <- data.frame(table(datos[, var]))
  tablaFreq <- data.frame(table(datos[, var]) / sum(table(datos[, var])))
  m <- match(tablaAbs$Var1, tablaFreq$Var1)
  tablaAbs[, "FreqRel"] <- tablaFreq[m, "Freq"]
  colnames(tablaAbs) <- c("Categoria", "FreqAbs", "FreqRel")
  cat("===============", var, "===================================/n")
  print(tablaAbs)
  cat("==================================================/n")
}
```

Las frecuencias absolutas de las variables categóricas, muestran, en general, una distribución equitativa de las modalidades. Sin embargo, la variable $time_signature$ posee un mayor número de casos en la cuarta categoría.

```{r}
# --- 2.1.2 Categorical: Graphics (base) -----------------------------------
# Configurar la ventana gráfica para mostrar 2 filas y 3 columnas
par(mfrow = c(2, 3))

# Crear gráficos de barras con títulos personalizados
for (var in varCat) {
  if (var == "time_signature") {
    barplot(table(datos[, var]),
            main = "Distribución de Time Signature",
            col = "skyblue")
  } else if (var == "key") {
    barplot(table(datos[, var]),
            main = "Distribución de Key",
            col = "lightgreen")
  } else if (var == "audio_mode") {
    barplot(table(datos[, var]),
            main = "Distribución de Audio Mode",
            col = "lightcoral")
  } else {
    barplot(table(datos[, var]),
            main = var,  # título genérico si hay más variables
            col = "gray80")
  }
}

# Restaurar la configuración original
par(mfrow = c(1, 1))
```

  - **time_signature**:
  
la categoría 4 es la más frecuente, con casi 8000 canciones. Esto corresponde al compás 4/4, el más común en música popular. El resto de niveles, 0, 1, 3 y 5 son mucho menos frecuentes, lo que indica que compases alternativos o inusuales son raros en esta colección de canciones.

  - **key**:
  
La distribución es bastante uniforme, con cada tonalidad apareciendo entre 1000 y 2000 veces.
No hay una tonalidad claramente dominante, lo que sugiere diversidad armónica en el conjunto de datos.

  - **audio_mode**:
  
Predominan las canciones en modo mayor, lo que puede reflejar una tendencia hacia música más optimista o comercial.

```{r}
# --- 2.1.2 Categorical: Graphics (ggplot2 + gridExtra) --------------------
library(gridExtra)

plots <- list()  # lista vacía
i <- 1           # índice

for (var in varCat) {
  tabla <- data.frame(table(datos[, var]) / sum(table(datos[, var])))
  p <- ggplot(data = tabla, aes(x = Var1, y = Freq)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    geom_text(aes(label = paste0(round(Freq * 100, 2), "%")),
              vjust = 1.6, color = "white", size = 3.5) +
    theme_minimal() +
    labs(title = paste("Distribución de", var), x = var, y = "Proporción")

  plots[[i]] <- p
  i <- i + 1
}
# Mostrar todos los gráficos en un grid (ejemplo con 2 columnas)
# grid.arrange(grobs = plots, ncol = 2)

```


```{r}
# --- 2.2 Bivariant analysis -----------------------------------------------

# 2.2.1 Numerical vs. numerical — Description
cor(na.omit(datos[, varNum]))
```

Las correlaciones con valores más extremos se encuentran entre las variables **acousticness** y **loudness**, **instrumentalness** y **loudness**, **loudness** y **energy**, **acousticness** y **energy**. 

```{r}
# 2.2.1 Numerical vs. numerical — Graphics (base / PerformanceAnalytics)
library(PerformanceAnalytics)
chart.Correlation(as.matrix(datos[, varNum]), histogram = TRUE, pch = 12)
```

```{r, include=FALSE, eval=FALSE}
# 2.2.1 Numerical vs. numerical — Graphics (ggplot2 / ggcorrplot)
library(ggcorrplot)
corr <- round(cor(datos[, varNum]), 1)
ggcorrplot(corr, lab = TRUE)
```

```{r}
# 2.2.2 Numerical vs. categorical — Description
for (varN in varNum) {
  for (varC in varCat) {
   print(psych::describeBy(datos[, varN], group = datos[, varC]))
  }
}
```

```{r}
# 2.2.2 Numerical vs. categorical — Graphics (ggplot2)
library(ggplot2)
library(gridExtra)

plots <- list()
i <- 1

for (varC in varCat) {
  for (varN in varNum) {
    grafico <- ggplot(datos, aes(x = .data[[varN]], fill = .data[[varC]])) +
      geom_histogram(colour = "black",
                     lwd = 0.75,
                     linetype = 1,
                     position = "identity",
                     alpha = 0.5) +
      labs(title = paste("Histograma de", varN, "por", varC),
           x = varN, y = "Frecuencia", fill = varC) +
      theme_minimal()
    plots[[i]] <- grafico
    i <- i + 1
  }
}
# Mostrar todos en un grid (2 columnas)
grid.arrange(grobs = plots, ncol = 2)
```

```{r}
# 2.2.3 Categorical vs. categorical — Description
for (varc1 in varCat) {
  for (varc2 in varCat) {
    if (varc1 != varc2) {
      prop_table <- prop.table(table(datos[, varc1], datos[, varc2]))
      cat("=============", varc1, " vs. ", varc2, "=========================/n")
      print(prop_table)
    }
  }
}
```


```{r}
# 2.2.3 Categorical vs. categorical — Graphics (base)
par(mfrow = c(3, 3))
for (varc1 in varCat) {
  for (varc2 in varCat) {
    if (varc1 != varc2) {
      prop_table <- prop.table(table(datos[, varc1], datos[, varc2]))
      barplot(prop_table, beside = TRUE)
    }
  }
}
par(mfrow = c(1, 1))
```

```{r}

# --- 3 Automatic Descriptive Analysis (EDA) -------------------------------

# 3.1 Skim
library(skimr)
library(tidyverse)

# Podem visualitzar un descriptiu de les dades
skim(datos)
```

```{r}
# Visualitzem exclusivament les variables numériques
skim(datos) %>% yank("numeric")
```

```{r}
skim(datos) %>% yank("character")
```

```{r}
# 3.2 Vis
library(visdat)
## Busquem per a variables numériques o categóriques si hi ha NA's
vis_dat(datos)
```

Este gráfico representa que la mayoría de las variables son numéricas, con menos cantidad de variables categóricas. También se osberva que hay un gran número de valores missings en los dos tipos de variables. 

```{r}
## Visualitzem percentatges de NA's en les variables
vis_miss(datos)
```

Concretamente, hay un total de 26% de valores perdidos. 

```{r}
## Generem la matriu de correlacions
datos %>% dplyr::select(where(is.numeric)) %>% vis_cor()
```

Mediante la visualización de este gráfico de correlaciones, se refuerzan las relaciones lineales entre los diferentes pares de variables. 

```{r}
## Podem visualitzar condicionants de les dades. En aquest cas, mirem si tenim mes de
## 2 clases
vis_expect(datos, ~ .x > 2)
```

```{r}
# 3.3 Inspectdf
library(inspectdf)

## Tipus de dades
inspect_types(datos) %>% show_plot()
```

La base de datos contiene 3 variables factor, y 11 cuantitativas. 

```{r}
## Utilització de la memoria
inspect_mem(datos) %>% show_plot()
```

```{r}
# Paquetes
library(dplyr)
library(inspectdf)
library(rlang)

# --- 1) Crear una categórica desde una numérica y comparar (High/Low) ---
# Usamos 'song_popularity' como ejemplo con umbral 50.
umbral <- 50
num_target <- "song_popularity"

stopifnot(num_target %in% c(
  "liveness","loudness","danceability","song_duration_ms","audio_valence",
  "energy","tempo","acousticness","speechiness","instrumentalness","song_popularity"
))

# Convertir a numérico por si viniera como texto
datos[[num_target]] <- suppressWarnings(as.numeric(datos[[num_target]]))

data_price_dummy <- datos %>%
  mutate(price_dummy = if_else(.data[[num_target]] > umbral, "High", "Low") %>% factor())

# Comparativa de NA entre High y Low
inspect_na(
  data_price_dummy %>% filter(price_dummy == "High"),
  data_price_dummy %>% filter(price_dummy == "Low")
) %>% show_plot()

```

```{r}
## Comprovem la distribució de les variables
inspect_num(datos) %>% show_plot()
```

```{r}
## check categorical variable distribution
inspect_imb(datos) %>% show_plot()
```

```{r}
## check two categorical
inspect_imb(data_price_dummy %>% dplyr::filter(price_dummy == "High"),
            data_price_dummy %>% dplyr::filter(price_dummy == "Low")) %>%
  show_plot() + theme(legend.position = "none")
```

```{r}
## similiar to inspect_imb, but for all levels
inspect_cat(datos) %>% show_plot()
```

```{r, eval=FALSE, include=FALSE}
inspect_cor(datos) %>% show_plot()
```

```{r}
# 3.5 DataExplorer
library(DataExplorer)
plot_str(datos)
introduce(datos)
```

```{r}
plot_intro(datos)
```

```{r}
plot_missing(datos)
```

Tal y como se muestra en esta ilustración, se ha asignado un 30% de valores missings en cada variable. 

```{r}
plot_bar(datos)
```

Cabe destacar que la variable $key$ posee una gran cantidad de valores faltantes, algo que deberá de tratarse en el preprocesamiento de los datos para evitar el sesgo y que este hecho pueda cambiar significativamente los resultados. Asimismo, $time_signature$ también presenta bastantes valores perdidos.  

```{r}
plot_histogram(datos)
```

Muchas de las distribuciones de las variables parecen tener asimetría, bien sea por la izquierda o por la derecha. Esto induce a pensar que variables como $acousticness$, $instrumentalness$,  $speechiness$ o $loudness$ tienden a tomar valores más extremos. 


```{r}
library(DataExplorer)

# Opción 1: omitir filas con NA
plot_correlation(na.omit(datos), type = "all", maxcat = 5L)
```

```{r}
library("SmartEDA")
## Overview of the data
ExpData(data = datos,type = 1)

## structure of the data    
ExpData(data = datos,type = 2)
```

```{r}
SmartEDA::ExpCTable(datos,Target=NULL,margin=1,clim=10,nlim=5,round=2,bin=NULL,per=T)
```

# 3. Outliers treatment

## 4.1. Tratamiento univariante con boxplots

```{r}
outliers_detectados <- list()

# Variables a analizar 
vars<-c("audio_valence","danceability","energy","log_acousticness",
        "log_liveness","song_duration_ms","tempo")

# Iteramos sobre las variables
for (i in vars){
  #Extraemos valores outliers usando IQR
  q1 = quantile(datos[[i]], 0.25, na.rm=TRUE)
  q3 = quantile(datos[[i]], 0.75, na.rm=TRUE)
  iqr = q3-q1
  lim_inf = q1-1.5*iqr
  lim_sup = q3+1.5*iqr
  
  out_ind <- which(datos[[i]] < lim_inf | datos[[i]] > lim_sup)
  datos_outliers <- datos[out_ind,]
  
  if (length(out_ind) > 0) {

    extremos <- datos_outliers %>%
      mutate(distancia_mediana = abs(.data[[i]] - median(datos[[i]], na.rm = TRUE))) %>%
      arrange(desc(distancia_mediana)) %>%
      dplyr::select(-distancia_mediana)

    extremos_top10 <- head(extremos, 10)
    outliers_detectados[[i]] <- extremos_top10

    # Mostramos info resumen
    cat(paste0("\n\nVariable: ", i,
               "\n ·Outliers detectados: ", nrow(datos_outliers),
               "\n ·10 Outliers más extremos: ", paste(extremos_top10[[i]], collapse = ", ")))

    # Generamos boxplot con ggplot2
    p <- ggplot(datos, aes(y = .data[[i]])) +
      geom_boxplot(fill = "salmon", outlier.color = "black", outlier.shape = 21, alpha = 0.6) +
      labs(title = paste("Boxplot de", i), y = i) +
      theme_minimal() +
      theme(plot.title = element_text(size = 14, face = "bold"))

    print(p)

  } else {
    message(paste("Variable:", i, "- Sin outliers detectados"))
  }
}

```
El análisis de valores atípicos mediante el criterio del rango intercuartílico (IQR) muestra diferencias entre las variables estudiadas.

La variable **audio_valence** no presenta valores atípicos. En cambio, **danceability** muestra 49 valores atípicos situados en la parte inferior. De manera similar, **energy** presenta 70 valores atípicos también en el inferior. **Song_duration_ms**, es la variable con más valores atípicos (436), asociada principalmente a duraciones muy superiores a la mitjana. Y finalmente, **tempo** contiene 44 valores extremos, mayoritariamente por encima de los 200 BPM.

## 4.2 Tratamiento multivariante con distancias  de Gower
```{r}

#install.packages("gower")
library(gower)
library(dplyr)
library(ggplot2)
library(tibble)

X <- vars_mixtas  # tu data.frame ya seleccionado
k <- 10           # vecinos (ajústalo 5–20)

# k-NN sobre el propio conjunto (primera columna suele ser el “self” con distancia 0)
topn <- gower_topn(X, X, n = nrow(X), k = k + 1)

# media de distancias a los k vecinos (excluyendo el self)
knn_score <- rowMeans(topn$distance[, -1, drop = FALSE])

# umbral y outliers (p.ej., top 1%)
umbral <- quantile(knn_score, 0.99)
idx_outliers <- which(knn_score > umbral)

# gráfico rápido
tibble(ID = seq_along(knn_score), score = knn_score) |>
  ggplot(aes(ID, score)) +
  geom_line(color = "steelblue") +
  geom_hline(yintercept = umbral, linetype = "dashed", color = "red") +
  labs(title = "Rareza (media kNN con Gower)", y = "Distancia media kNN")

# filtrar
datos_limpio <- datos[-idx_outliers, ]

```



# Variables a analizar 

